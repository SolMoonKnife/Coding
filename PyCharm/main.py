# 최대 공약수를 구하는 유클리드 메서드
def gcd(m, n):
    # m > n 보장
    m, n = (m, n) if m > n else (n, m)
    if m % n == 0:
        return n
    else:
        return gcd(n, m%n)

import numpy as np
for i in range(30):
    m, n = tuple(map(int, (100*np.random.rand()+1, 100*np.random.rand()+1)))
    print(f"(m, n): ({m}, {n}), gcd({m}, {n}): {gcd(m, n)}")
    
# 순환적으로 생각하기
'''
1. 일반적으로 굳이 순환적으로 해결할 필요가 없는 함수를 순환 함수로 작성해보자.
문자열의 길이를 구하는 함수는?
-> 문자열의 길이는 문자 1개 + 나머지 문자열의 길이와 같다.
-> 문자를 하나씩 제거하면서 문자열이 빌 때까지 1 + (나머지 문자열 길이) 순환 호출을 반복한다.
-> 문자열이 빈 경우 0을 반환한다.
-> (*)C언어에서의 구현은 문자열 포인터로 참조할 때 문자가 나오는데, 널 문자이면 빈 것으로 간주
-> 순환 호출은 문자열 포인터에 1을 더하면 다음 문자를 가리키게 된다.
순차 탐색 알고리즘을 구현하는 함수는?
-> 마지막 인덱스부터 시작하여 마지막 원소를 검사하고, 찾는 값이 아니면 1줄인 인덱스를 통해 순환 호출
-> 만일 인덱스가 0이하가 된다면 찾는 값이 없다고 간주한다. 값을 찾은 경우 인덱스를 반환한다.
'''

# 주어진 정수를 이진수로 반환하는 순환 함수를 구현해보세요.

def binaryPrint(n):
    if n < 2:
        print(n, end='')  # 결과적으로 가장 깊은 호출 단계에서 이 문장이 처음 실행된다.
    else:
        binaryPrint(n//2)
        print(n%2, end='')
        

def binaryTrans(n, step=0):
    if n < 2:
        return n * (10**step)
    else:
        return binaryTrans(n//2, step+1) + (n%2) * (10**step)
    

"""
solution(0)
    solution(1)
        solution(2)
            print(3)  # 중단 조건, 가장 앞 자리
        print(2)
    print(1)
print(0)
"""

print(str(binaryTrans(5))+'(2)')

# 오름차순으로 정렬된 두 개의 집합이 주어질 때 두 배열의 정수들이 disjoint한가? 즉 교집합이 공집합인가?
def isDisjoint(m, A, n, B):
    # 집합의 크기 m, n
    if m <= 0 or n <= 0:
        return True
    elif A[m-1] == B[n-1]:
        return False
    elif A[m-1] > B[n-1]:
        return isDisjoint(m-1, A, n, B)
    else:
        return isDisjoint(m, A, n-1, B)

A = [1, 4, 5, 7, 8]
B = [2, 5, 6, 9]
C = [1, 2, 3, 4]
D = [5, 6, 7, 8, 9]
print(isDisjoint(5, A, 4, B))
print(isDisjoint(4, C, 5, D))

# 모든 순환함수는 반복문으로 표현할 수 있고, 반대로 모든 반복문도 순환으로 표현할 수 있음.
# 순환함수는 복잡한 알고리즘을 알기 쉽게 표현할 수 있는 도구이기도 하지만, 함수 호출에 의한 오버헤드가 존재.

# 순환 설계: 순환을 중단시키는 적어도 하나의 베이스 케이스가 있어야 함. 모든 일반 케이스는 베이스 케이스로 수렴해야 한다.
# 함수의 목적을 구체적으로 정의해야 한다. 순환을 이해하는 기본 원리는 수학적 귀납법의 논리 구조이기 때문이다.
# 암시적 매개변수를 명시적 매개변수로 바꿔라. -> "초기 값을 매개변수로 표현하라"는 것과 같음
# 일반적으로 어떤 함수를 작성할 때와 달리 순환 함수의 매개변수는 순환 호출 시마다
# 변화하는 목적을 나타낼 수 있는 모든 매개변수를 명시적으로 가지고 있어야 한다.
# 파이썬에서는 매개변수로 리스트를 전달할 때 리스트의 크기를 함께 전달할 필요가 없지만,
# 순환 호출 시 필요한 리스트의 구간이 달라지는 상황을 고려하여 크기 매개변수를 함께 작성할 수 있다.
# 반복문 구조를 가진 함수나, 초기 호출 시에는 '당연히' 처음부터 끝까지일 지라도,
# 순환 호출 시 처음과 끝이 달라질 수 있다. 이를 '당연히' 암시적으로 사용하지 말고 명시하라는 것이다.

# 투썸 문제: 배열에서 합이 k인 쌍이 존재하는 지 검사한다.
# -> 오름차순으로 정렬한 후 맨 앞과 맨 뒤 원소의 합을 검사하여
#    k보다 작으면 앞 인덱스를 증가시키고, k보다 크면 뒤 인덱스를 감소시킨다.